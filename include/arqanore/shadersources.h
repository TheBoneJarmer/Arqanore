#pragma once

#define SHADER_FONT_F "#version 330 core\nout vec4 frag_color;\n\nin vec4 color;\nin vec2 texcoord;\n\nuniform sampler2D u_image;\n\nvoid main() {\n    vec4 tex_color = texture(u_image, texcoord);\n    vec4 result_color = vec4(1.0, 1.0, 1.0, tex_color.r) * color;\n\n    frag_color = result_color;\n}\n"
#define SHADER_FONT_V "#version 330 core\nin vec2 a_position;\nin vec2 a_texcoord;\n\nuniform vec2 u_resolution;\nuniform vec2 u_rotation;\nuniform vec2 u_translation;\nuniform vec2 u_scale;\nuniform vec4 u_color;\n\nout vec4 color;\nout vec2 texcoord;\n\nvoid main() {\n    vec2 vertex = a_position;\n    vertex = vertex * u_scale;\n    vertex = vec2(vertex.x * u_rotation.y + vertex.y * u_rotation.x, vertex.y * u_rotation.y - vertex.x * u_rotation.x);\n    vertex = vertex + u_translation;\n    vertex = vertex / u_resolution;\n    vertex = (vertex * 2.0) - 1.0;\n\n    color = u_color;\n    texcoord = a_texcoord;\n\n    gl_Position = vec4(vertex.x, -vertex.y, 0, 1);\n}\n"
#define SHADER_MODEL_F "#version 330 core\n#define DIRECTIONAL_LIGHT 0\n#define POINT_LIGHT 1\n\nout vec4 frag_color;\n\nstruct Light {\n    vec3 source;\n    vec3 color;\n    int type;\n    bool enabled;\n    float strength;\n    float range;\n};\n\nstruct Material {\n    vec3 color;\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    float shininess;\n\n    sampler2D diffuse_map;\n    sampler2D ambient_map;\n    sampler2D specular_map;\n    int diffuse_map_active;\n    int ambient_map_active;\n    int specular_map_active;\n};\n\nuniform vec3 u_view_pos;\nuniform Material u_material;\nuniform int u_light_count;\nuniform Light u_light[99];\n\nin vec3 frag_pos;\nin vec3 vertex;\nin vec3 normal;\nin vec2 texcoord;\n\nvec3 calc_dir_light(Light light) {\n    vec3 light_normal = normalize(normal);\n    vec3 light_dir = normalize(-light.source);\n    float light_diffuse = max(dot(light_normal, light_dir), 0.0);\n\n    vec3 view_dir = normalize(u_view_pos - frag_pos);\n    vec3 reflect_dir = reflect(-light_dir, light_normal);\n    float light_specular = pow(max(dot(view_dir, reflect_dir), 0.0), u_material.shininess);\n\n    vec3 ambient = light.color * u_material.ambient;\n    vec3 diffuse = light.color * light_diffuse * u_material.diffuse;\n    vec3 specular = light.color * light_specular * u_material.specular;\n\n    if (u_material.diffuse_map_active == 1) {\n        vec3 diffuse_map_color = texture(u_material.diffuse_map, texcoord).xyz;\n\n        diffuse *= diffuse_map_color;\n        ambient *= diffuse_map_color;\n        specular *= diffuse_map_color;\n    }\n\n    if (u_material.ambient_map_active == 1) {\n        ambient *= texture(u_material.ambient_map, texcoord).xyz;\n    }\n\n    if (u_material.specular_map_active == 1) {\n        specular *= texture(u_material.specular_map, texcoord).xyz;\n    }\n\n    return (ambient + diffuse) * u_material.color;\n}\n\nvec3 calc_point_light(Light light) {\n    vec3 light_normal = normalize(normal);\n    vec3 light_dir = normalize(light.source - frag_pos);\n    float light_diffuse = max(dot(light_normal, light_dir), 0.0);\n\n    vec3 view_dir = normalize(u_view_pos - frag_pos);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n    float light_specular = pow(max(dot(view_dir, halfway_dir), 0.0), u_material.shininess);\n\n    float light_dist = length(light.source - frag_pos);\n    float light_att = 1.0 / light_dist * light.strength;\n    //float light_att = 1.0 / (1.0 + 0.09 * light_dist + 0.032 * (light_dist * light_dist));\n\n    if (light_dist > light.range) {\n        return vec3(0, 0, 0);\n    }\n\n    vec3 ambient = light.color * u_material.ambient * light_att;\n    vec3 diffuse = light.color * light_diffuse * u_material.diffuse * light_att;\n    vec3 specular = light.color * light_specular * u_material.specular * light_att;\n\n    if (u_material.diffuse_map_active == 1) {\n        vec3 diffuse_map_color = texture(u_material.diffuse_map, texcoord).xyz;\n\n        diffuse *= diffuse_map_color;\n        ambient *= diffuse_map_color;\n        specular *= diffuse_map_color;\n    }\n\n    if (u_material.ambient_map_active == 1) {\n        ambient *= texture(u_material.ambient_map, texcoord).xyz;\n    }\n\n    if (u_material.specular_map_active == 1) {\n        specular *= texture(u_material.specular_map, texcoord).xyz;\n    }\n\n    return (ambient + diffuse + specular) * u_material.color;\n}\n\nvoid main() {\n    vec4 result = vec4(0, 0, 0, 1);\n\n    for (int i=0; i<u_light_count; i++) {\n        if (!u_light[i].enabled) {\n            continue;\n        }\n\n        if (u_light[i].type == DIRECTIONAL_LIGHT) {\n            result.xyz += calc_dir_light(u_light[i]);\n        }\n\n        if (u_light[i].type == POINT_LIGHT) {\n            result.xyz += calc_point_light(u_light[i]);\n        }\n    }\n\n    frag_color = clamp(result, 0, 1);\n}\n"
#define SHADER_MODEL_V "#version 330 core\nlayout (location = 0) in vec3 a_vertex;\nlayout (location = 1) in vec3 a_normal;\nlayout (location = 2) in vec2 a_texcoord;\nuniform mat4 u_model_matrix;\nuniform mat4 u_mesh_matrix;\nuniform mat4 u_view_matrix;\nuniform mat4 u_projection_matrix;\n\nout vec3 frag_pos;\nout vec3 vertex;\nout vec3 normal;\nout vec2 texcoord;\n\nvoid main() {\n    mat4 mat_model = u_model_matrix * u_mesh_matrix;\n    mat4 mat_mvp = u_projection_matrix * u_view_matrix * mat_model;\n    mat3 mat_normal = mat3(transpose(inverse(mat_model)));\n\n    frag_pos = vec3(mat_model * vec4(a_vertex, 1.0));\n    vertex = (u_view_matrix * mat_model * vec4(a_vertex, 1.0)).xyz;\n    normal = mat_normal * a_normal;\n    texcoord = a_texcoord;\n    \n    gl_Position =  mat_mvp * vec4(a_vertex, 1.0);\n}\n"
#define SHADER_POLYGON_F "#version 330 core\nout vec4 frag_color;\n\nin vec4 color;\nin vec2 texcoord;\n\nuniform sampler2D u_texture;\nuniform int u_texture_active;\nuniform int u_flip_hor;\nuniform int u_flip_vert;\n\nvoid main() {\n    vec4 final_color = color;\n    vec2 final_texcoord = texcoord;\n\n    if (u_flip_hor == 1) {\n        final_texcoord.x *= -1;\n    }\n\n    if (u_flip_vert == 1) {\n        final_texcoord.y *= -1;\n    }\n\n    if (u_texture_active == 1) {\n        final_color *= texture(u_texture, final_texcoord);\n    }\n\n    frag_color = final_color;\n}\n"
#define SHADER_POLYGON_V "#version 330 core\nprecision mediump float;\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec2 a_texcoord;\n\nuniform vec2 u_resolution;\nuniform vec2 u_rotation;\nuniform vec2 u_translation;\nuniform vec2 u_scale;\nuniform vec4 u_color;\nuniform vec2 u_origin;\nuniform vec2 u_offset;\n\nout vec4 color;\nout vec2 texcoord;\n\nvoid main() {\n    vec2 vertex = a_vertex - u_origin;\n    vertex = vertex * u_scale;\n    vertex = vec2(vertex.x * u_rotation.y + vertex.y * u_rotation.x, vertex.y * u_rotation.y - vertex.x * u_rotation.x);\n    vertex = vertex + u_translation;\n    vertex = vertex / u_resolution;\n    vertex = (vertex * 2.0) - 1.0;\n\n    color = u_color;\n    texcoord = a_texcoord + u_offset;\n\n    gl_Position = vec4(vertex.x, -vertex.y, 0, 1);\n}\n"
#define SHADER_SPRITE_F "#version 330 core\nout vec4 frag_color;\n\nin vec4 color;\nin vec2 texcoord;\n\nuniform sampler2D u_texture;\nuniform int u_flip_hor;\nuniform int u_flip_vert;\n\nvoid main() {\n    vec2 final_texcoord = texcoord;\n\n    if (u_flip_hor == 1) {\n        final_texcoord.x *= -1;\n    }\n\n    if (u_flip_vert == 1) {\n        final_texcoord.y *= -1;\n    }\n\n    frag_color = color * texture(u_texture, final_texcoord);\n}\n"
#define SHADER_SPRITE_V "#version 330 core\nprecision mediump float;\n\nlayout (location = 0) in vec2 a_vertex;\nlayout (location = 1) in vec2 a_texcoord;\n\nuniform vec2 u_resolution;\nuniform vec2 u_rotation;\nuniform vec2 u_translation;\nuniform vec2 u_scale;\nuniform vec4 u_color;\nuniform vec2 u_origin;\nuniform vec2 u_offset;\n\nout vec4 color;\nout vec2 texcoord;\n\nvoid main() {\n    vec2 vertex = a_vertex - u_origin;\n    vertex = vertex * u_scale;\n    vertex = vec2(vertex.x * u_rotation.y + vertex.y * u_rotation.x, vertex.y * u_rotation.y - vertex.x * u_rotation.x);\n    vertex = vertex + u_translation;\n    vertex = vertex / u_resolution;\n    vertex = (vertex * 2.0) - 1.0;\n\n    color = u_color;\n    texcoord = a_texcoord + u_offset;\n\n    gl_Position = vec4(vertex.x, -vertex.y, 0, 1);\n}\n"
